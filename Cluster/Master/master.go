package main

import (
	"fmt"
	"net"
	"net/http"
	"net/rpc"
	"os"
	"strconv"
	"sync"
	"time"

	"github.com/google/uuid"

	"github.com/mohamed247/Distributed_Web_Crawler/Cluster/RPC"
	crawling "github.com/mohamed247/Distributed_Web_Crawler/Functionality"
	logger "github.com/mohamed247/Distributed_Web_Crawler/Logger"
)

const localhost string = "127.0.0.1"

func main(){
	port :=  os.Args[1]


	master, err := MakeMaster(localhost + ":" + port)
	
	if err != nil{
		logger.LogError(logger.CLUSTER, "Exiting becuase of error creating a master: %v", err)
		os.Exit(1)
	}


	//later on, will be using rabbit mq
	testUrl := "https://www.google.com/"
	websitesNum := 1000
	master.DoCrawl(testUrl, websitesNum)

	wg := sync.WaitGroup{}
	wg.Add(1)
	wg.Wait() 
}

const 
(
	TaskAvailable = iota
	TaskAssigned
	TaskDone
)

type Master struct{
	id string
	port string

	baseUrls []string   //urls generated by the master initially, to distribute the work after
	workerPorts map[string]string  //map to keep track of socketName for each worker
	URLsMap map[string]bool //map of whether a url has been visited or not    
	URLsTasks map[string]int //map of whether a url task has been done, assigned, or is available

	workersTimers []time.Time  //keep track of last time a task was issued

	masterMu sync.Mutex
}


func MakeMaster(port string) (*Master, error){
	guid, err := uuid.NewRandom()

	if err != nil{
		logger.LogError(logger.MASTER, "Error generationg uuid: %v", err)
		return nil, err
	}

	master := &Master{
		id: guid.String(),
		port: port,
		URLsMap: make(map[string]bool),
		workersTimers: make([]time.Time, 2),
		masterMu: sync.Mutex{},
	}

	master.server()


	return master, nil;

}



//
// RPC handlers
//

func (master *Master) HandleGetTasks(args *RPC.GetTaskArgs, reply *RPC.GetTaskReply) error {
	logger.LogInfo(logger.MASTER, "A worker requested to be given a task %v", args)

	// var links []string
	// copy(links, master.baseUrls)

	// //keep sending rpcs until links array finally reaches needed length
	// for len(links) < urlsNum{
		
	// 	//the reason behind looping on links from the beginning every time is
	// 	//so since some of the previous tasks given out may have not been actually done

	// 	for i, v := range links {				
	// 		//a task is indeed available to distribute

	// 		if (master.URLsTasks[v] == TaskAvailable){
	// 			//distribute work over all active workers
	// 			for i, v := range master.workersAlive{
	// 				if v{ //worker is indeed alive
	// 					go func(idx int){
							
	// 					}(i)
	// 				}
	// 				ma
	// 			}
	// 		}else if (master.URLsTasks[v] == TaskAssigned){
	// 			//a task has been assigned, need to check if 
	// 		}
	// 	}
		
	// }
	return nil
}



//in the future, will take the work from rabbitmq
func (master *Master) DoCrawl(url string, urlsNum int) ([]string, error){
	//first, need to crawl this url once, to extract all pages
	//then distribute the crawling

	//TODO clear up all the data from the previous crawl

	logger.LogInfo(logger.MASTER, 
		"Recieved a request to crawl this website %v and get %v links from it",
		url, urlsNum)

	links, err := crawling.GetURLs(url)
	if err != nil{
		logger.LogError(logger.MASTER, "Error while crawling: %v", err)
		return nil, err
	}

	master.URLsMap[url] = true  //successfully crawled this webpage

	if len(links) >= urlsNum{
		//no need to distribute tasks, just send the current array after removing extra links
		links = links[:urlsNum]
		return links, nil
	}

	return nil, nil

}


//
// start a thread that listens for RPCs
//
func (master *Master) server() error{
	rpc.Register(master)
	rpc.HandleHTTP()

	
	os.Remove(master.port)
	listener, err := net.Listen("tcp", master.port)
	
	if err != nil {
		logger.LogError(logger.MASTER, "Error while listening on socket: %v", err)
		return err
	}

	logger.LogInfo(logger.MASTER, "Listening on socket: %v", master.port)

	go http.Serve(listener, nil)
	return nil
}





//
// find an empty port between 8000 and 9000 to listen on
//
func generatePortNum() (int, *net.Listener, error){
	for i := 8000; i <= 9000; i++{
		listener, err := net.Listen("tcp", localhost + ":" + strconv.Itoa(i))
		if err != nil{
			continue
		}
		//successfully found a free port
		return i, &listener, nil
	}
	return -1,nil, fmt.Errorf("unable to find an empty port")
}

